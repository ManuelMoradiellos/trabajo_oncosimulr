---
title: 'OncoSimulR: Simulating pathways and mutual exclusivity.'
author: "Blanca Lacruz Pleguezuelos, Víctor Mateo Cáceres, Manuel Moradiellos Corpus"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    df_print: paged
  bookdown::html_document2:
    css: custom4.css
    toc: yes
    toc_float: yes
    fig_retina: null
    fig_caption: yes
classoption: a4paper
geometry: margin=3cm
fontsize: 12pt
bibliography: trabajo_oncosimul.bib
biblio-style: apalike
link-citations: yes
vignette: |
  %\VignetteIndexEntry{OncoSimulR: Simulating pathways and mutual exclusivity.} %\VignetteEngine{knitr::rmarkdown}  %\VignettePackage{OncoSimulR}  %\VignetteEncoding{UTF-8}  %\VignetteDepends{OncoSimulR}
---

```{r setup, include = FALSE}
time0 <- Sys.time()
knitr::opts_chunk$set(echo = TRUE, collapse = FALSE)
options(width = 70)
require(BiocStyle)
require(pander)
require(OncoSimulR)
require(ggplot2)
require(reshape2)
```

# Colorectal cancer model from Cristea et al., 2017 

pathTiMEx is an algorithm that takes cancer datasets and generates a probabilistic
model describing tumor progression in its temporal order of mutations in
mutually exclusive driver pathways.  

The first few examples that we will show come from a colorectal cancer dataset
provided in @wood07 that @cristea17 used to showcase their algorithm; pathTiMEx
founds two possible trajectories for this set of mutations, depending on whether
a linear path (order of mutations) was used as a restriction or not.  

## Examples of colorectal cancer model without linear progression ## {#pathex1}

On the left-hand side of Figure 3A we can see the optimal set of pathway mutations
inferred by pathTiMEx without using the limitation of a linear path; the results
obtained were consonant with previous knowledge.

```{r path3a, echo=FALSE, out.width="70%", out.height="70%", fig.cap="Figure 3A, left panel"}
knitr::include_graphics("figures/path_figure3a.png")
```

This figure shows that the temporal order of mutations in APC, KRAS and TP53
is maintained. There are two modules with mutual exclusivity, TP53/EVC2 and
PIK3CCA/EPHA3, that do not have a parent node but are nevertheless represented.
This means that order restrictions for mutations in these modules are not 
known, but the authors did find that these mutations occur at certain time 
points in tumor progression: mutations in TP53/EVC2 usually happen after
mutations in KRAS, while mutations in the PIK3CA/EPHA3 module were found to 
take place in later stages of tumor progression.

### 1st approach: Nodes with unkown requisites branching from the root

With `OncoSimulR` we can represent this situation of knowing the temporal order
as in _"Mutation X happens after mutation in Y"_, creating a simple DAG of 
restrictions where the nodes with unknown restrictions simply branch from the
root node (i.e., the wild type):

```{r path_ex1_fig3a_DAG}
# Will be needed to plot the drivers
wood_drv <- c("APC", "KRAS", "TP53", "EVC2", "FBXW7", "TCF7L2", "PIK3CA", "EPHA3")

# Creating the DAG using genes modules 
wood_root <- allFitnessEffects(data.frame(
                              parent = c("Root", "Root", "Root", "A", "B", "C"),
                              child = c("A", "C", "E", "B", "D", "D"),
                              s = 0.2,
                              sh = -0.9,
                              typeDep = "MN"),
                              geneToModule = c("Root" = "Root",
                                               "A" = "APC",
                                               "B" = "KRAS",
                                               "C" = "TP53, EVC2",
                                               "D" = "FBXW7, TCF7L2",
                                               "E" = "PIK3CA, EPHA3"),
                              drvNames = wood_drv
                              )

plot(wood_root, expandModules = TRUE, autofit = TRUE)
```

Now we could obtain the fitness landscape for this model, but the result is a
very busy plot:

```{r path_ex1_fig3a_FitLandscape}
# We could obtain the fitness for each genotype combination, 
# but it results in very busy plots as there are many combinations:
eAG_wood_root <- evalAllGenotypes(wood_root)

plot(eAG_wood_root)  # Overlapping labels
plot(eAG_wood_root, show_labels = FALSE) # Still not very good
```

A further step would be using the OncoSimulR function `oncoSimulIndiv` to
simulate tumor progression. As a lot of genotypes appear during this simulation,
we decided to plot the progression in the number of drivers instead:

```{r path_ex1_fig3a_simul}
simul_wood_root <- oncoSimulIndiv(wood_root,
                              model="McFL",
                              onlyCancer = FALSE,
                              finalTime = 5000,
                              verbosity = 0,
                              mu = 1e-5,
                              initSize = 2000,
                              keepPhylog = TRUE,
                              seed = NULL,
                              detectionProb = NA,
                              detectionSize = NA,
                              detectionDrivers = NA,
                              errorHitMaxTries = FALSE,
                              errorHitWallTime = FALSE
                              )

# Since plotting genotypes results in a very busy plot,
# we will only plot the number of drivers:

# xlim = c(0, 5000) shows full time-lapse for comparison of 
# clones with five vs. six mutated drivers

plot(simul_wood_root, addtot = TRUE, lwdClone = 0.9, log = "",
     thinData = TRUE, thinData.keep = 0.3,
     plotDiversity = TRUE,
     xlim = c(0, 5000)) 

## Another flavor of plotting
plot(simul_wood_root, type = "stacked", thinData = TRUE, 
     thinData.keep = 0.1,
     plotDiversity = TRUE,
     xlim = c(0, 5000))
```

We can see that the main clones have 5 mutations in driver genes, which makes
sense according to the DAG. Clones with 6-7 mutated drivers are those in which
genes with mutual exclusivity are mutated. Their frequency is very low, but they
do appear: sh is not -1 because the most likely explanation for this mutual
exclusivity is a lack of positive selection rather than synthetic lethality
(i.e. clones with both mutations are not viable.) 

If we look carefully at the DAG of restrictions for this model we will see that
it is possible to get genotypes in which TP53 is mutated before KRAS is, or even
genotypes in which mutations in the PIK3CA/EPHA3 module occur at the beginning of
tumor progression rather than in later stages. For this particular simulation, 
the genotypes that appear are: 

```{r pathx_ex1_fig3a_tree}
plotClonePhylog(simul_wood_root)
```

[[[[ Metemos aquí la caja de código con el árbol. Yo el párrafo que dejo debajo lo 
    quitaría, porque depende de cómo salga la simulación y justo en el HTML que 
    nos pasaste sí se respeta el orden!  He puesto un párrafo encima de estos
    comentarios que creo que podría ser una buena alternativa   ]]]]
        
If we look at the phylogenetic tree, we can see that there are clones in which
the order **APC --> KRAS --> TP53**, which is well-established in the literature,
is not respected (as we could already guess from the DAG of restrictions):

### 2nd approach: Adding order effects

We could use the same DAG of restrictions but adding order effects;
the authors do not mention or suggest the existence of these effects in this
case, but we believe this hypothesis is not contradictory to the graph either.
In fact, we think the following graph would be the one that makes the least 
assumptions about the data including the temporal information about the order
in which mutations are believed to happen in this type of tumors.

1. The positive effect on fitness is higher if mutations in KRAS happen before 
mutations in TP53/EVC2 compared to the opposite order. 
2. The same thing happens if mutations in PIK3CA/EPHA3 appear once KRAS is mutated.
3. As the authors consider that mutations in PIK3CA/EPHA3 appear in late stages 
of tumor progression, we considered that mutating these genes after mutations in 
KRAS appear results in a higher fitness as well.

```{r path_ex2_fig3a_order_effects}
wood_order <- allFitnessEffects(data.frame(
        parent = c("Root", "A", "B", "C"),
        child = c("A", "B", "D", "D"),
        s = 0.2,
        sh = -0.9,
        typeDep = "MN"),
        geneToModule = c("Root" = "Root",
                         "A" = "APC",
                         "B" = "KRAS",
                         "C" = "TP53, EVC2",
                         "D" = "FBXW7, TCF7L2",
                         "E" = "PIK3CA, EPHA3"),
        drvNames = wood_drv,
        orderEffects = c("B > C" = 0.02,
                         "B > E" = 0.02,
                         "C > E" = 0.01)
        )

plot(wood_order, expandModules = TRUE, autofit = TRUE)

# Save all fitness values for later comparison
eAG_wood_order <- evalAllGenotypes(wood_order)
```

We could perform simulations with `oncoSimulPop`, which calls `oncoSimulIndiv`
multiple times (in this case, 25):

```{r path_ex2_simul}
simul_order <- oncoSimulPop(25, wood_order,
                              model = "McFL",
                              onlyCancer = FALSE,
                              finalTime = 5000,
                              verbosity = 0,
                              keepPhylog = TRUE,
                              initSize = 2000,
                              mu = 1e-5,
                              sampleEvery = .03,
                              keepEvery = 1,
                              detectionProb = NA,
                              detectionSize = NA,
                              detectionDrivers = NA,
                              errorHitMaxTries = FALSE,
                              errorHitWallTime = FALSE)
```

Now, we will take a sample from this simulation and plot the resulting genotypes:

```{r path_ex2_simul_sample}
sp_order <- samplePop(simul_order, "unif", "singleCell")
ordered.df <- sp_order[ , c(1, 5, 8, 3, 4, 7, 6, 2)] # Reorders columns
df.long <- melt(ordered.df) # Convert wide to long
gg <- ggplot(subset(df.long, value == 1), aes(x = Var1, y = Var2))
gg <- gg + geom_point(size = 3, shape = 22, aes(fill = Var2))
gg <- gg + labs(y = "Mutated gene", x = "Simulation")
gg
```

### One step further: What if these nodes depend on KRAS?
Now that we believe we have implemented the model described by the authors, we
wanted to model a situation in which the modules TP53/EVC2 and PIK3CA/EPHA3
depend from KRAS. Note that this is different from the model described by the
authors, as we are now assuming a restriction that they did not report: 


```{r path_ex3_fig3a_order_effects_kras}
wood_kras <- allFitnessEffects(data.frame(
                              parent = c("Root", "A", "B", "B", "B", "C"),
                              child = c("A", "B", "D", "C", "E", "E"),
                              s = 0.2,
                              sh = -0.9,
                              typeDep = "MN"),
                              geneToModule = c("Root" = "Root",
                                               "A" = "APC",
                                               "B" = "KRAS",
                                               "C" = "TP53, EVC2",
                                               "D" = "PIK3CA, EPHA3",
                                               "E" = "FBXW7, TCF7L2"),
                              drvNames = wood_drv
                              )

plot(wood_kras, expandModules = TRUE, autofit = TRUE)

eAG_wood_kras <- evalAllGenotypes(wood_kras) # We will use this later
```

We could perform the same simulation as before, and the resulting figure
would be quite similar:

```{r path_ex3_simul}
simul_kras <- oncoSimulPop(25, wood_kras,
                              model = "McFL",
                              onlyCancer = FALSE,
                              finalTime = 5000,
                              verbosity = 0,
                              keepPhylog = TRUE,
                              initSize = 2000,
                              mu = 1e-5,
                              sampleEvery = .03,
                              keepEvery = 1,
                              detectionProb = NA,
                              detectionSize = NA,
                              detectionDrivers = NA,
                              errorHitMaxTries = FALSE,
                              errorHitWallTime = FALSE)

sp_kras <- samplePop(simul_kras, "unif", "singleCell")

ordered.df <- sp_kras[ , c(1, 5, 8, 3, 4, 7, 6, 2)] # Reorders columns
df.long <- melt(ordered.df) # Convert wide to long
gg <- ggplot(subset(df.long, value == 1), aes(x = Var1, y = Var2))
gg <- gg + geom_point(size = 3, shape = 22, aes(fill = Var2))
gg <- gg + labs(y = "Mutated gene", x = "Simulation")
gg
```

## Example of colorectal cancer model with linear progression

This particular case was made by the authors to compare their approach to the
one by @vandin15. This model does not respect the order
in driver mutations that we already mentioned, as mutations in TP53 would appear
before mutations in KRAS, and imposes an "artificial" restriction on tumor 
progression by enforcing a linear progression. We still thought it could be 
illustrative to show the DAG of restrictions, but we will not go deeper into
this model.

The DAG was taken from the left-hand side of Figure 4A.

```{r path4a, echo=FALSE, out.width="30%", out.height="30%", fig.cap=" Figura 4A de PathTiMEx."}
knitr::include_graphics("figures/path_figure4a.png")
```

The resulting DAG of restrictions would be:

```{r path_ex1_fig4a}
wood_linear <- allFitnessEffects(data.frame(parent = c("Root", "A", "B", "C"),
                                     child = c("A", "B", "C", "D"),
                                     s = 0.2,
                                     sh = -0.9,
                                     typeDep = "MN"),
                                  geneToModule = c("Root" = "Root",
                                                   "A" = "APC, EPHA3",
                                                   "B" = "EVC2, PIK3CA, TP53",
                                                   "C" = "KRAS, TCF7L2",
                                                   "D" = "FBXW7"),
                                  drvNames = wood_drv
                                  )


plot(wood_linear, expandModules = TRUE, autofit = TRUE)
```


## Order effects vs. monotonic dependency

We have seen four approaches. Three of them use Figure 3A as base to build
the DAG, with small differences as there are two nodes (TP53/EVC2 and PIK3CA/
EPHA2) that the authors describe as "independent" and that do not have a
parent node in the graph. In order to include these nodes in our model, we 
have devised three possible approaches: 

(1) these nodes come from the root node (i.e. the wild type) (Section \@ref(pathex1)); 
(2) these nodes are independent (as the authors suggest) and the effects of 
    these mutations are different depending on the order in which they occur;
(3) these nodes are both child nodes from KRAS.

The last approach (4) is based on Figure 4A, where a linear progression is 
imposed, but we will not focus on this one as we believe it is imposing 
artificial restraints on tumor progression.

As for approaches (2) and (3), the former is what we believe results in a most
accurate description of the model, as it does not assume any new dependencies. We
decided to implement approach number (3) as well because we thought it would be
interesting to compare both of them and what they mean. 

As the fitness landscapes resulting from `evalAllGenotypes` show a lot of 
genotypes and are not readable, we will focus on specific genotypes and compare
their resulting fitnesses. 

First, if we look at genotypes where only APC, KRAS and TP53 are mutated in the
`wood_order` model, we will see what these order effects mean (the symbol '>'
between two genes A and B, 'A > B', means that A is mutated before B):

```{r path_ex_discuss_1}

## If we use order effects, these genotypes will have different fitnesses:
eAG_wood_order[grep("^APC > TP53 > KRAS$", eAG_wood_order[,1]),]

#              Genotype Fitness
# 104 APC > TP53 > KRAS    1.44

# 1. 44 = 1.2 * 1.2

eAG_wood_order[grep("^APC > KRAS > TP53$", eAG_wood_order[,1]),] 

#            Genotype Fitness
# 88 APC > KRAS > TP53  1.4688

# 1.4688 = 1.2 * 1.2 * 1.02 --> extra advantage thanks to the order effects
```

In the `wood_kras` model, there is only one possible genotype, in which all
restrictions are followed and the mutation order is APC > KRAS > TP53:

```{r path_ex_discuss_2}
eAG_wood_kras[54,] 
 
#           Genotype Fitness
# 54 APC, KRAS, TP53   1.728

# 1.728 = 1.2 * 1.2 * 1.2
```

We would see a similar thing if we added mutations in PIK3CA to the previous
examples. Moving on, it is also interesting to study the fitness of genotypes 
such as those in which only PIK3CA and TP53 are mutated. This respects all 
restrictions in the `wood_order` model, but does not in the `wood_kras` one, 
resulting in very different fitnesses. This is a very explicit way to see that
the two models are, in fact, very different from each other; and that assuming
an extra restriction has great effects on fitness:

```{r path_ex_discuss_3}

eAG_wood_kras[35,] 

#        Genotype Fitness
# 35 PIK3CA, TP53    0.01

# 0.01 = 0.1 * 0.1

eAG_wood_order[grep("^PIK3CA > TP53$", eAG_wood_order[,1]),]

#         Genotype Fitness
# 50 PIK3CA > TP53       1

# 1 --> There is no positive (or negative) effect on fitness
# relative to the wild type

eAG_wood_order[grep("^TP53 > PIK3CA$", eAG_wood_order[,1]),] 

#         Genotype Fitness
# 63 TP53 > PIK3CA    1.01

# 1.01 = 1 * 1.01
```
