---
title: 'OncoSimulR: Simulating pathways and mutual exclusivity.'
author: "Blanca Lacruz Pleguezuelos, Víctor Mateos Cáceres, Manuel Moradiellos Corpus"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    css: custom4.css
    toc: yes
    toc_float: yes
    fig_retina: null
    fig_caption: yes
classoption: a4paper
geometry: margin=3cm
fontsize: 12pt
bibliography: trabajo_oncosimul.bib
biblio-style: "apalike"
link-citations: true
vignette: >
  %\VignetteIndexEntry{OncoSimulR: Simulating pathways and mutual exclusivity.}
  %\VignetteEngine{knitr::rmarkdown} 
  %\VignettePackage{OncoSimulR} 
  %\VignetteEncoding{UTF-8} 
  %\VignetteDepends{OncoSimulR}
---

```{r setup, include = FALSE}
time0 <- Sys.time()
knitr::opts_chunk$set(echo = TRUE, collapse = FALSE)
options(width = 70)
require(BiocStyle)
require(pander)
library(OncoSimulR)
```

# Introduction
Understating the factors involved in tumor progression can lead to highlight
gene interactions or key mutations that would be valuable for various 
therapeutic purposes.  

One of the tools used to do so are cancer progression models ( _CPMs_ ), which
allow us to identify the constrains or dependencies in the order of accumulation
of mutations that take place during tumor development. They return directed
acyclic graphs ( _DAGs_ ) in which the vertices or nodes are the potentially
mutated genes, and their restriction/relationships are the edges of the graph;
thus representing the possible genotypes that can occur in that tumor.  

Another convenient approach to understand cancer progression are fitness landscapes,
which specify the observed genotypes and their fitness delimiting paths from 
the wild-type to further stages as it accumulates mutations. 

Although fitness landscapes are highly useful, obtaining them isn't as easy as
delimiting _DAGs_ from a _CPM_. Both methods aren't interchangeable as _DAGs_ 
have some limitations; they represent the order of viable mutations needed
to transpire in the progression of a tumor, this is representative of sign
epistasis, a phenomenon that describes that the effect of a gene mutation depends
on its genetic background. But only providing the possible succession of mutations
and no fitness details of those genotypes is an important restriction as there
are other relevant events found in cancer, such as reciprocal sign epistasis, 
that it isn't able to describe but fitness landscapes can (@uriarte18).   

Reciprocal sign epistasis is an event in which the genetic interaction of two
co-occurring mutations has an effect on the fitness of the genotype different
from the one they have individually; this comes in two flavors: synthetic 
lethality when the combination of those mutations is lethal to the cell, and
synthetic viability when their co-occurrence increases the overall fitness.  
This phenomena are well manifested in fitness landscapes as peaks and valleys.  

This high variance of fitness due to mutation interactions materializes as 
multiple possible evolutionary paths in fitness landscapes, where the order of 
mutations can have restrictions or show patterns of complementarity or exclusivity
(either synthetic lethality or the fact gaining a second mutation on the same
pathway doesn´t increase fitness).  

As many tumor progression models are based on DAGs and carry their limitations,
various algorithms have been created to infer pathway modules with their order of
mutation accumulation coming from cross-sectional data to obtain better models 
(@schill19).

Genes in modules? What more to explain in the introduction

In this assignment we will use OncoSimulR's capabilities to map the simulation
of data of those models to show various possible interactions such as 
mutual exclusivity.
 
# Colorectal cancer model from @cristea17 

pathTiMEx is an algorithm that takes cancer dataset and generates a probabilistic
model describing tumor progression in its temporal order of mutations in
mutually exclusive driver pathways.  

The first few examples that we will show come from a colorectal cancer dataset
provided in @wood07 that @cristea17 used to showcase their algorithm; pathTiMEx
founds two possible trajectories for this set of mutations, depending on whether
a linear path (order of mutations) was used as a restriction or not.  

## Examples of colorectal cancer model without linear progression

On the left-hand side of Figure 3A we can see the optimal set of pathway mutations
inferred by pathTiMEx without using the limitation of a linear path; the results
obtained were consonant with previous knowledge.

![pathTiMEx, colorectal cancer Figure 3A Left](figures/path_figure3a.png){height="720px"}

Whats relevant about this order of mutations is that the succession of mutational
events in regards to TP53/EVC2 and PIK3CA/EPHA3 take place after the ones at KRAS,
which is the consensus of other studies on this tumor progression.

### 1st approach: Nodes with unkown requisites branching from the root

With OncoSimulR we can represent this situation of knowing the temporal order
as in _"Mutation X happens after mutation in Y"_, creating a simple DAG of 
restrictions:

```{r path_ex1_fig3a}
# To obtain reproducible simulation results
set.seed(1)

# Will be needed to plot the drivers
wood_drv <- c("APC", "KRAS", "TP53", "EVC2", "FBXW7", "TCF7L2", "PIK3CA", "EPHA3")

# Creating the DAG using genes modules 
wood_root <- allFitnessEffects(data.frame(
                              parent = c("Root", "Root", "Root", "A", "B", "C"),
                              child = c("A", "C", "E", "B", "D", "D"),
                              s = 0.2,
                              sh = -0.9,
                              typeDep = "MN"),
                              geneToModule = c("Root" = "Root",
                                               "A" = "APC",
                                               "B" = "KRAS",
                                               "C" = "TP53, EVC2",
                                               "D" = "FBXW7, TCF7L2",
                                               "E" = "PIK3CA, EPHA3"),
                              drvNames = wood_drv
                              )

plot(wood_root, expandModules = TRUE)

# We could obtain the fitness for each genotype combination, 
# but it results in very busy plots
eAG_wood_root <- evalAllGenotypes(wood_root)

plot(eAG_wood_root)  # Overlapping labels
plot(eAG_wood_root, show_labels = FALSE) # Still not very good

# Simulating all appearing genotypes isn't good either
simul_wood_root <- oncoSimulIndiv(wood_root,
                              model="McFL",
                              onlyCancer = FALSE,
                              finalTime = 5000,
                              verbosity = 0,
                              mu = 1e-5,
                              initSize = 2000,
                              keepPhylog = TRUE,
                              seed = NULL,
                              detectionProb = NA,
                              detectionSize = NA,
                              detectionDrivers = NA,
                              errorHitMaxTries = FALSE,
                              errorHitWallTime = FALSE
                              )

# Since plotting genotypes results in a very busy plot,
# we will only# plot the number of drivers:

plot(simul_wood_root, addtot = TRUE, lwdClone = 0.9, log = "",
     thinData = TRUE, thinData.keep = 0.3,
     plotDiversity = TRUE,
     xlim = c(0, 5000)) # Showing full time-lapse for comparison of
                        # clones with five vs. six mutated drivers

## Another flavor of plotting
plot(simul_wood_root, type = "stacked", thinData = TRUE, 
     thinData.keep = 0.1,
     plotDiversity = TRUE,
     xlim = c(0, 5000))
```
We can see that the main clones have 5 mutations in driver genes, which makes
sense according to the DAG. Clones with 6-7 mutated drivers are those in which
genes with mutual exclusivity are mutated. Their frequency is very low, but they
do appear: sh is not -1 because the most likely explanation for this mutual
exclusivity is a lack of positive selection rather than synthetic lethality
(i.e. clones with both mutations are not viable.)  

If we look at the phylogenetic tree, we can see that there are clones in which
the order **APC --> KRAS --> TP53**, which is well-established in the literature,
is not respected (as we could already guess from the DAG of restrictions):

```{r pathx_ex1_fig3a_tree}
plotClonePhylog(simul_wood_root)
```

### 2nd approach: Adding order of effects

We could use the same DAG of restrictions but adding order effects;
the authors do not mention or suggest the existence of these effects in this
case, but we believe this hypothesis is not contradictory to the graph either.
In fact, we think the resulting graph is the one that makes the least assumptions
about the data, even though it might not be the one that performs better in 
cancer cell simulations (see discussion below).  

1. The positive effect of mutating TP53/EVC2 before KRAS is very low. 
2. The same thing happens when mutating PIK3CA/EPHA3 before KRAS..
3. I do not penalize with a negative fitness effect because this would imply 
   that the clone is less viable when mutations happen this way, and I am not 
   sure that we would want to say that.

```{r path_ex2_fig3a_order_effects}
wood_order <- allFitnessEffects(data.frame(
        parent = c("Root", "A", "B", "C"),
        child = c("A", "B", "D", "D"),
        s = 0.2,
        sh = -0.9,
        typeDep = "MN"),
        geneToModule = c("Root" = "Root",
                         "A" = "APC",
                         "B" = "KRAS",
                         "C" = "TP53, EVC2",
                         "D" = "FBXW7, TCF7L2",
                         "E" = "PIK3CA, EPHA3"),
        drvNames = wood_drv,
        orderEffects = c("C > B" = 0.05,
                         "E > B" = 0.01) #, "E > C" = 0.01, "E > A" = 0.001),
)

plot(wood_order, expandModules = TRUE)

eAG_wood_order <- evalAllGenotypes(wood_order)
```

### 3rd approach: Nodes with unkown prerequisites branch from KRAS
The previous example followed the auhtors and figure best, where the nodes/modules
for TP53/EVC2 and PIK3CA/EPAH3 didn't have a parent root per se; given that those
modules do not depend on KRAS according to what we could read, we know will show
another example for the sake of incorporating the temporal information known 
using KRAS as the prerequisite for those alterations:

```{r path_ex3_fig3a_order_effects_kras}
wood_kras <- allFitnessEffects(data.frame(
                              parent = c("Root", "A", "B", "B", "B", "C"),
                              child = c("A", "B", "D", "C", "E", "E"),
                              s = 0.2,
                              sh = -0.9,
                              typeDep = "MN"),
                              geneToModule = c("Root" = "Root",
                                               "A" = "APC",
                                               "B" = "KRAS",
                                               "C" = "TP53, EVC2",
                                               "D" = "PIK3CA, EPHA3",
                                               "E" = "FBXW7, TCF7L2"),
                              drvNames = wood_drv
                              )

plot(wood_kras, expandModules = TRUE)

eAG_wood_kras <- evalAllGenotypes(wood_kras)

plot(eAG_wood_kras)

# To try and see the genotypes that appear:
simul_wood_kras <- oncoSimulIndiv(wood_kras,
                                  model="McFL",
                                  onlyCancer = FALSE,
                                  finalTime = 5000,
                                  verbosity = 0,
                                  mu = 1e-5,
                                  initSize = 2000,
                                  keepPhylog = TRUE,
                                  seed = NULL,
                                  detectionProb = NA,
                                  detectionSize = NA,
                                  detectionDrivers = NA,
                                  errorHitMaxTries = FALSE,
                                  errorHitWallTime = FALSE)

# Again, two possible plots

plot(simul_wood_kras, addtot = TRUE, lwdClone = 0.9, log = "",
     thinData = TRUE, thinData.keep = 0.3,
     plotDiversity = TRUE,
     xlim = c(0, 5000)) 

plot(simul_wood_kras, type = "stacked", thinData = TRUE, 
     thinData.keep = 0.1,
     plotDiversity = TRUE,
     xlim = c(0, 1000))  # Longer time limit didn't 
                         # show much more, we changed it
```


## Examples of colorectal cancer model with linear progression

This particular case was made by the authors to compare their approach to the
one by @vandin15. This model does not respect the order
in driver mutations that we already mentioned and imposes an "artificial" 
restriction on tumor progression (linear progression). Even though it isn´t
very informative due to that discrepancy in the order of mutations, we decided 
to implement this example as well to see how it does in simulations.

The DAG was taken from the left-hand side of Figure 4A.

![pathTiMEx, colorectal cancer Figure 4A Left](figures/path_figure4a.png)

```{r path_ex1_fig4a}
wood_linear <- allFitnessEffects(data.frame(parent = c("Root", "A", "B", "C"),
                                     child = c("A", "B", "C", "D"),
                                     s = 0.2,
                                     sh = -0.9,
                                     typeDep = "MN"),
                                  geneToModule = c("Root" = "Root",
                                                   "A" = "APC, EPHA3",
                                                   "B" = "EVC2, PIK3CA, TP53",
                                                   "C" = "KRAS, TCF7L2",
                                                   "D" = "FBXW7"),
                                  drvNames = wood_drv
                                  )


plot(wood_linear, expandModules = TRUE, autofit = TRUE)

eAG_wood_linear <- evalAllGenotypes(wood_linear)

plot(eAG_wood_linear) # Looks hideous

simul_wood_linear <- oncoSimulIndiv(wood_linear,
                              model="McFL",
                              onlyCancer = FALSE,
                              finalTime = 5000,
                              verbosity = 0,
                              mu = 1e-5,
                              initSize = 2000,
                              keepPhylog = TRUE,
                              seed = NULL,
                              detectionProb = NA,
                              detectionSize = NA,
                              detectionDrivers = NA,
                              errorHitMaxTries = FALSE,
                              errorHitWallTime = FALSE)


plot(simul_wood_linear, addtot = TRUE, lwdClone = 0.9, log = "",
     thinData = TRUE, thinData.keep = 0.3,
     plotDiversity = TRUE, 
     xlim = c(0, 1000))

plot(simul_wood_linear, type = "stacked", thinData = TRUE, 
     thinData.keep = 0.1,
     plotDiversity = TRUE,
     xlim = c(0, 1000))

```


## Discussion of the simulated data (so far)

We have seen four approaches. Three of them use Figure 3A as base to build
the DAG, with small differences as there are two nodes (TP53/EVC2 and PIK3CA/
EPHA2) that the authors describe as "independent" and that do not have a
parent node in the graph. In order to include these nodes in our model, we 
have devised three possible approaches: 

* (1) these nodes come from the root node (i.e. the wild type); 
* (2) these nodes are independent (as the authors suggest) and the effects of 
  these mutations are different depending on the order in which they occur;
* (3) these nodes are both child nodes from KRAS. 

The last approach (4) is based on Figure 4A, where a linear progression is 
imposed, but we will not focus on this one as we believe it is imposing 
artificial restraints on tumor progression.

We believe that approaches (2) and (3) are the ones that best model the 
information provided by the authors, as they both consider the fact that 
mutations in TP53/EVC2 and in PIK3CA/EPHA3 are observed at certain points in
time. But which one is better? We selected some genotypes from the 
`evalAllGenotypes` output in order to see exactly what is going on:

Genotypes starting with PIK3CA (we could do this with more genotypes if
we wanted to):

```{r path_ex_discuss}
# From 1st approach
eAG_wood_root[grep("^PIK3CA", eAG_wood_root[,1]),]

# From 2nd approach
eAG_wood_order[grep("^PIK3CA", eAG_wood_order[,1]),]

# From 3rd approach
eAG_wood_kras[grep("^PIK3CA", eAG_wood_kras[,1]),]
```

Which of these is better? Well, it seems that in wood_kras clones with the 
genotype "PIK3CA" will appear less frequently, as their fitness is very low.
Should the fitness of these clones be lower than 1? This is an interesting
question. In this case, the fitness of 0.100 comes from the sh penalty applied
to genotypes that deviate from the DAG of restrictions. 

We probably need to know a lot more about the mechanisms of tumor progression
in colorectal cancer to answer this question correctly. If we focus only on 
replicating what the authors saw in this data set, the wood_kras model is 
probably the "best" (most accurate) one, and the one that best reproduces
the *APC --> KRAS --> TP53* mutation order.

Even when the authors could not find a dependency of having KRAS
mutated in order to have either of the modules TP53/EVC2 or PIK3CA/EPHA2 
mutated, which is what our DAG reflects, this simplification was necessary to 
integrate the temporal information that the authors had, but could not 
translate into a graph of dependencies. 

}------|Comentario de Blanca|------{
Lo que quiero decir ah? arriba ^ es que si que no es correcto decir que estos
dos modulos dependen de KRAS porque no es eso lo que dice el paper, pero que 
es la unica forma de integrar de alguna manera la informacion temporal que
comentan (incluso asi perdemos algo de informacion).

Creo que en realidad solo usan el modelo lineal para comparar su m?todo con 
el de Raphael and Vandin, asi que si vemos que queda muy largo lo podemos 
quitar de la presentacion (me pareceria tonteria quitarlo del documento que 
entreguemos porque al final es trabajo hecho...)

# Examples of glioblastoma

## Models from @cristea17

@cristea17 also showcased pathTiMEx's performance using a large gliobastoma 
dataset from The Cancer Genome Atlas Program (TCGA) (@cerami12); we will
map the DAG coming from the left-hand side of Figure 3C.

```{r tomate, echo=FALSE, out.width="90%", out.height="90%", fig.cap="\\label{fig:tomate}Ye."}
knitr::include_graphics("figures/path_figure3c.png")
```

In Figure \@ref(fig:tomate) we notice its low quality

### 1st Possible representation of the DAG

```{r path_fig3c_full}
gb_drv <- c("CDKN2A", "CDK4", "TP53-M", "MDM4", "MDM2", 
            "NF1", "FAF1", "SPTA1", "OBSCN", "CNTNAP2", 
            "PTEN-M", "PTEN-D", "PIK3CA", "IDH1",
            "PDGFRA", "LRP2", "EGFR", "RB1", "TP53-D", "PAOX")

# All nodes with unknown prerequisites/previous mutations will
# be modeled as if they branch from Root
TCGA_gb_root <- allFitnessEffects(data.frame(
                  parent = c("Root", "A", "Root", "Root", "B", "C", "D", "Root"),
                  child = c("A", "B", "C", "D", "E", "E", "E", "F"),
                  s = 0.2,
                  sh = -0.9,
                  typeDep = "OR"),
                  geneToModule = c("Root" = "Root",
                                   "A" = "CDKN2A, CDK4",
                                   "B" = "TP53-M, MDM4, MDM2",
                                   "C" = "NF1, FAF1, SPTA1, OBSCN, CNTNAP2",
                                   "D" = "PTEN-M, PTEN-D, PIK3CA, IDH1",
                                   "E" = "PDGFRA, LRP2",
                                   "F" = "EGFR, RB1, TP53-D, PAOX"),
                  drvNames = gb_drv)

plot(TCGA_gb_root, expandModules = TRUE, autofit = TRUE)
```

As there is a large number of possible genotype combinations, `evalAllGenotypes`
doesn't work; we'll simplify the model with the following ideas in mind:

* We get rid of Module C as it does not appear in another we will
  compare this one to (the one from @ciriello12)
* For the rest of the modules, we only keep the ones that also appear
  in that paper
* We join PTEN mutations as one  

We end up with this code

```{r path_fig3c_simple}

gb_drv_simple <- c("CDKN2A", "CDK4", "TP53-M", "MDM4", "MDM2", 
                    "PTEN", "PIK3CA",
                    "PDGFRA", "EGFR", "RB1")
TCGA_gb_root_simple <- allFitnessEffects(data.frame(
                  parent = c("Root", "A", "Root", "Root", "B", "D", "Root"),
                  child = c("A", "B", "D", "E", "E", "E", "F"),
                  s = 0.2,
                  sh = -0.9,
                  typeDep = "OR"),
                  geneToModule = c("Root" = "Root",
                                   "A" = "CDKN2A, CDK4",
                                   "B" = "TP53-M, MDM4, MDM2",
                                   "D" = "PTEN, PIK3CA",
                                   "E" = "PDGFRA",
                                   "F" = "EGFR, RB1, TP53-D"),
                  drvNames = gb_drv_simple)

plot(TCGA_gb_root_simple, expandModules = TRUE, autofit = TRUE)

eAG_TCGA_rs <- evalAllGenotypes(TCGA_gb_root_simple, max = 2100) # No tarda mucho

plot(eAG_TCGA_rs) # Hideous, can be omitted

simul_TCGA_rs <- oncoSimulIndiv(TCGA_gb_root_simple,
                                    model="McFL",
                                    onlyCancer = FALSE,
                                    finalTime = 5000,
                                    verbosity = 0,
                                    mu = 1e-5,
                                    initSize = 2000,
                                    keepPhylog = TRUE,
                                    seed = NULL,
                                    detectionProb = NA,
                                    detectionSize = NA,
                                    detectionDrivers = NA,
                                    errorHitMaxTries = FALSE,
                                    errorHitWallTime = FALSE)

# With time = 1000 it plots something bonico, but with 5000
# it takes more time and forbidden genotypes appear

plot(simul_TCGA_rs, addtot = TRUE, lwdClone = 0.9, log = "",
     thinData = TRUE, thinData.keep = 0.3,
     plotDiversity = TRUE,
     xlim = c(0, 1000))

plot(simul_TCGA_rs, type = "stacked", thinData = TRUE, 
     thinData.keep = 0.1,
     plotDiversity = TRUE,
     xlim = c(0, 1000))

```

### 2nd Possible representation of the DAG

```{r}
TCGA_gb_2 <- allFitnessEffects(data.frame(
                    parent = c("Root", rep("A", 3), rep(c("B", "C", "D"), 2)),
                    child = c("A", "B", "C", "D", rep("E", 3), rep("F", 3)),
                    s = 0.2,
                    sh = -0.9,
                    typeDep = "OR"),
                    geneToModule = c("Root" = "Root",
                                     "A" = "CDKN2A, CDK4",
                                     "B" = "TP53-M, MDM4, MDM2",
                                     "C" = "NF1, FAF1, SPTA1, OBSCN, CNTNAP2",
                                     "D" = "PTEN-M, PTEN-D, PIK3CA, IDH1",
                                     "E" = "PDGFRA, LRP2",
                                     "F" = "EGFR, RB1, TP53-D, PAOX"))
plot(TCGA_gb_2, expandModules = TRUE, autofit = TRUE)

# We simplify again the initial idea:
TCGA_gb_2_simple <- allFitnessEffects(data.frame(
                    parent = c("Root", rep("A", 2), rep(c("B", "D"), 2)),
                    child = c("A", "B", "D", rep("E", 2), rep("F", 2)),
                    s = 0.2,
                    sh = -0.9,
                    typeDep = "OR"),
                    geneToModule = c("Root" = "Root",
                                     "A" = "CDKN2A, CDK4",
                                     "B" = "TP53-M, MDM4, MDM2",
                                     "D" = "PTEN, PIK3CA",
                                     "E" = "PDGFRA",
                                     "F" = "EGFR, RB1, TP53-D"),
                    drvNames = gb_drv_simple)

plot(TCGA_gb_2_simple, expandModules = TRUE, autofit = TRUE)

eAG_TCGA_2s <- evalAllGenotypes(TCGA_gb_2_simple, max = 2100) 

plot(eAG_TCGA_2s) # Also hideous

simul_TCGA_2s <- oncoSimulIndiv(TCGA_gb_2_simple,
                                model="McFL",
                                onlyCancer = FALSE,
                                finalTime = 5000,
                                verbosity = 0,
                                mu = 1e-5,
                                initSize = 2000,
                                keepPhylog = TRUE,
                                seed = NULL,
                                detectionProb = NA,
                                detectionSize = NA,
                                detectionDrivers = NA,
                                errorHitMaxTries = FALSE,
                                errorHitWallTime = FALSE)


plot(simul_TCGA_2s, addtot = TRUE, lwdClone = 0.9, log = "",
     thinData = TRUE, thinData.keep = 0.3,
     plotDiversity = TRUE,
     xlim = c(0, 1000))

plot(simul_TCGA_2s, type = "stacked", thinData = TRUE, 
     thinData.keep = 0.1,
     plotDiversity = TRUE,
     xlim = c(0, 1000))
```


## Models from @ciriello12

@ciriello12
```{r, echo=FALSE, out.width="130%", out.height="130%", fig.cap="Mi vieja."}
knitr::include_graphics("figures/ciriello_figure2.png")
```


@mohag20

![Mohaghegh 2020, colorectal cancer Figure 8C](figures/mohag_figure8c.png){height="720px"}

## Figures
You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.



